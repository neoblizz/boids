Based on the 3 rules we further implement other optimization approaches of our own. 
\subsection{Performance}
Iterating all flockmates for each boid per frame is too expensive and may cause tones of lagging or even crashing. We took Sebastian Lagueâ€™s project as a reference and implemented a GPU based multi-thread iteration for calculating the three key parameters mentioned above. This allows each boid has one thread paralyzed running on GPU and iterates simultaneously. 

\subsection{Realistic}
We also add a random force to each boid every 20 frames. In some situation(e.g. When the flock move straight forward for a time), the boids situation keeps no change and makes the whole flock look too ordered and becomes even sterile. So an uneven force with random direction is added to make more change to the flock motion. This force is not designed to completely break the flock order and reform again but to downgrade the precision of computer calculated simulation and make the motion more realistic. We also tried to implement a gravity to the system, but we find this did almost nothing different without it.

\subsection{Avoid Obstacle}

The interaction with the obstacle object is the most interesting part of the whole simulation. It makes the flock motion more random and unpredictable when it comes across an object with complex shape. Sometimes the boids could be further divided into several smaller groups but the whole motion looks still reasonable and you could feel the small clusters still forming one single flock. 
\begin{center}
  \includegraphics[width=5cm, height=3cm]{{docs/fig/rays.png}}
  \end{center}
The strategy to achieve this is complicated. Craig W. Reynolds mentioned two different attempts: force field model and steer-to-avoid, and we implemented the latter one since it has a better performance. We designed several rays sending from the front of the boids to detect if there are obstacles ahead. The challenge is, directly detecting the collision of rays on the surface of an object could be very expensive if the object is polyhedral. It turns to be even more complicated to further figure out the direction for a boid to avoid the object, especially under 3D. We simplify this question by casting the obstacle into a sphere. In this case for each ray sending from boid, the obstacle could be measured as a circle on a 2D panel with this ray. With this casting process, we solve 2 problems together: the complexity of directions in 3D and arbitrary shape of obstacles. 
\begin{center}
  \includegraphics[width=5cm, height=3cm]{{docs/fig/avoid1.png}}
\end{center}
When an obstacle is detected, a normalized force will be added to the boid on the same panel of the detection ray. This force is designed to turn the heading of the current boid and the angle it turns will be based on the golden ratio. In some simplified cases, for example, if a boid heading perpendicular to a flat surface, the boid will steer a golden spiral to avoid a collision. This is designed to avoid sharp turns and make the whole process smooth and natural. Since the flock is still maintaining during the avoid process, the avoid force is added based on the 3 rules and it is not necessary to worry about whether the force from the 3 rules may affect the performance of avoiding.
\begin{center}
  \includegraphics[width=4cm, height=3cm]{{docs/fig/golden spirial.jpg}}
\end{center}

\subsection{Prey and Predator}

To test the durability of our system, we introduced a prey and predator into our system to simulate a real natural scene.

The prey randomly picks a point in the 3D scene and move toward that point. To make the motion of prey smooth and real, we implement a force from the position of prey to the target point on prey each frame. When the prey reaches the target, another point will be randomly picked. The flock chases the prey in a similar way. A force heading the prey is added on every boid each frame together with 3 rules. To make the scene more simple we set the speed of prey always greater than the boids so the flock never catches up. 

We also added a predator to chase the flock. The predator is always heading the center of the flock and the strategy is exactly the same as boid chasing prey. Each boid gets an updated predator position each frame. If the distance of predator is less than an avoid radius an escape force will be added toward an opposite direction of the predator on boid. The difference between avoiding predators and obstacles is the boids do not follow three rules when escaping predators. We notice that three rules should not be implemented to simulate avoid predators since alignment and cohesion always playing a dominant role in boid motion. Even we set an escape weight and set it 10 times more than the weights for three rules, the flock still does not show a distinct escaping motion while predator approaches. In our implementation, we only reserve the separation part and set a significantly higher speed to boid, in order to match a similar escaping scene from the natural world.
